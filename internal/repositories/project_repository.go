package repositories

import (
	"database/sql"
	"time"

	"pentest-report/internal/models"

)

type ProjectRepository struct {
	DB *sql.DB
}

func NewProjectRepository(db *sql.DB) *ProjectRepository {
	return &ProjectRepository{DB: db}
}

// AddProject adds a new project to the database
func (repo *ProjectRepository) AddProject(project *models.Project) error {
	// Chuẩn bị truy vấn SQL
	query := `INSERT INTO projects (name, description) VALUES (?, ?)`

	// Thực hiện truy vấn SQL để thêm project vào cơ sở dữ liệu
	_, err := repo.DB.Exec(query, project.Name, project.Description)
	if err != nil {
		return err
	}

	return nil
}

// CheckProjectExist kiểm tra xem tên project đã tồn tại hay chưa
func (repo *ProjectRepository) CheckProjectExist(name string) (bool, error) {
    var count int
	query := "SELECT COUNT(*) FROM projects WHERE name = ?"
	err := repo.DB.QueryRow(query, name).Scan(&count)
    if err != nil {
        return false, err
    }
    return count > 0, nil
}

// GetAllProjectsWithTotalReports trả về danh sách tất cả các projects kèm theo tổng số báo cáo của mỗi project
func (repo *ProjectRepository) GetAllProjectsWithTotalReports() ([]models.ProjectWithTotalReports, error) {
	var projects []models.ProjectWithTotalReports

	query := `
		SELECT p.id, p.name, p.description, DATE(p.created_at) AS created_at, COUNT(r.id) AS total_report
		FROM projects p
		LEFT JOIN reports r ON p.id = r.project_id
		GROUP BY p.id
	`
	rows, err := repo.DB.Query(query)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

    for rows.Next() {
        var project models.ProjectWithTotalReports
        if err := rows.Scan(&project.ID, &project.Name, &project.Description, &project.CreatedAt, &project.TotalReports); err != nil {
            return nil, err
        }
        projects = append(projects, project)
    }

	return projects, nil
}


func (repo *ProjectRepository) GetProjectDetailByID(projectID int) (*models.ProjectDetail, error) {
	var projectDetail models.ProjectDetail

	// Query project details
	projectQuery := `
		SELECT p.id, p.name, p.description, DATE(p.created_at) as created_at, 
		       COALESCE(COUNT(r.id), 0) as total_reports
		FROM projects p
		LEFT JOIN reports r ON p.id = r.project_id
		WHERE p.id = ?
		GROUP BY p.id
	`
	err := repo.DB.QueryRow(projectQuery, projectID).Scan(
		&projectDetail.ID, &projectDetail.Name, &projectDetail.Description,
		&projectDetail.CreatedAt, &projectDetail.TotalReports,
	)
	if err != nil {
		return nil, err
	}

	// Query report authors
	authorQuery := `
		SELECT DISTINCT r.author
		FROM reports r
		WHERE r.project_id = ?
	`
	authorRows, err := repo.DB.Query(authorQuery, projectID)
	if err != nil {
		return nil, err
	}
	defer authorRows.Close()

	for authorRows.Next() {
		var author string
		if err := authorRows.Scan(&author); err != nil {
			return nil, err
		}
		projectDetail.ReportAuthors = append(projectDetail.ReportAuthors, author)
	}

	// Query reports
	reportQuery := `
		SELECT r.id, r.name, DATE(r.date), r.author, r.status
		FROM reports r
		WHERE r.project_id = ?
	`
	reportRows, err := repo.DB.Query(reportQuery, projectID)
	if err != nil {
		return nil, err
	}
	defer reportRows.Close()

	for reportRows.Next() {
		var report models.ProjectReport
		var date string
		if err := reportRows.Scan(&report.ID, &report.Name, &date, &report.Author, &report.Status); err != nil {
			return nil, err
		}

		// Convert date string to time.Time
		report.Date, err = time.Parse("2006-01-02", date)
		if err != nil {
			return nil, err
		}

		projectDetail.Reports = append(projectDetail.Reports, report)
	}

	return &projectDetail, nil
}

func (repo *ProjectRepository) DeleteProject(projectID int) error {
    query := "DELETE FROM projects WHERE id = ?"
    _, err := repo.DB.Exec(query, projectID)
    return err
}

func (repo *ProjectRepository) UpdateProject(projectID int, project *models.ProjectUpdate) error {
    query := `
        UPDATE projects
        SET name = ?, description = ?, date = ?
        WHERE id = ?
    `
    _, err := repo.DB.Exec(query, project.Name, project.Description, project.Date, projectID)
    return err
}