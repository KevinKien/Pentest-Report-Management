package repositories

import (
	"database/sql"
    "errors"

	"pentest-report/internal/models"

)

// UserRepository defines methods to interact with user data
type UserRepository struct {
    DB *sql.DB
}

// NewUserRepository creates a new user repository
func NewUserRepository(db *sql.DB) *UserRepository {
    return &UserRepository{DB: db}
}

// GetUserByUsername retrieves a user by username from the database
func (repo *UserRepository) GetUserByUsername(username string) (*models.User, error) {
    query := "SELECT id, username, password, role FROM users WHERE username = ?"
    row := repo.DB.QueryRow(query, username)

    user := &models.User{}
    err := row.Scan(&user.ID, &user.Username, &user.Password, &user.Role)
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, nil // User not found
        }
        return nil, err
    }

    return user, nil
}

// AddUser adds a new user to the database
func (repo *UserRepository) AddUser(user *models.User) error {
    query := "INSERT INTO users (username, password, role) VALUES (?, ?, ?)"
    _, err := repo.DB.Exec(query, user.Username, user.Password, user.Role)
    if err != nil {
        return err
    }
    return nil
}

// CheckUsernameExists kiểm tra xem username đã tồn tại hay chưa
func (repo *UserRepository) CheckUsernameExists(username string) (bool, error) {
    var count int
    query := "SELECT COUNT(*) FROM users WHERE username = ?"
    err := repo.DB.QueryRow(query, username).Scan(&count)
    if err != nil {
        return false, err
    }
    return count > 0, nil
}

// GetAllUsers trả về tất cả người dùng từ cơ sở dữ liệu
func (repo *UserRepository) GetAllUsers() ([]*models.User, error) {
    var users []*models.User

    query := "SELECT id, username, role FROM users"
    rows, err := repo.DB.Query(query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    for rows.Next() {
        user := &models.User{}
        if err := rows.Scan(&user.ID, &user.Username, &user.Role); err != nil {
            return nil, err
        }
        users = append(users, user)
    }

    return users, nil
}

func (repo *UserRepository) DeleteUser(userID int) error {
    query := "DELETE FROM users WHERE id = ?"
    _, err := repo.DB.Exec(query, userID)
    return err
}

func (repo *UserRepository) UpdateUser(userID int, user *models.User) error {
    query := `
        UPDATE users
        SET username = ?, password = ?, role = ?
        WHERE id = ?
    `
    _, err := repo.DB.Exec(query, user.Username, user.Password, user.Role, userID)
    return err
}

func (repo *UserRepository) ChangePassword(userID int, changePasswordRequest *models.ChangePasswordRequest) error {
    // Verify old password
    var storedPassword string
    query := "SELECT password FROM users WHERE id = ?"
    err := repo.DB.QueryRow(query, userID).Scan(&storedPassword)
    if err != nil {
        return err
    }

    if storedPassword != changePasswordRequest.OldPassword {
        return errors.New("old password does not match")
    }

    // Update with new password
    query = "UPDATE users SET password = ? WHERE id = ?"
    _, err = repo.DB.Exec(query, changePasswordRequest.NewPassword, userID)
    return err
}

func (repo *UserRepository) GetTopUsersByFindings() ([]models.UserWithFindings, error) {
    query := `
        SELECT u.id, u.username, COUNT(f.id) as total_findings
        FROM users u
        LEFT JOIN findings f ON u.username = f.author
        GROUP BY u.id, u.username
        ORDER BY total_findings DESC
        LIMIT 10;
    `
    rows, err := repo.DB.Query(query)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var users []models.UserWithFindings
    for rows.Next() {
        var user models.UserWithFindings
        if err := rows.Scan(&user.ID, &user.Username, &user.TotalFindings); err != nil {
            return nil, err
        }
        users = append(users, user)
    }
    return users, nil
}