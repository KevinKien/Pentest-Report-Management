package repositories

import (
    "database/sql"
    "strings"
    "time"

    "pentest-report/internal/models"

)

type FindingRepository struct {
    DB *sql.DB
}

func NewFindingRepository(db *sql.DB) *FindingRepository {
    return &FindingRepository{DB: db}
}

// AddFinding adds a new finding to the database
func (repo *FindingRepository) AddFinding(finding *models.Finding) error {
    query := `
        INSERT INTO findings (report_id, name, status, severity, weakness, description, impact, image_url, link, recommend, author, created_at)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `
    _, err := repo.DB.Exec(query,
        finding.ReportID,
        finding.Name,
        finding.Status,
        finding.Severity,
        finding.Weakness,
        finding.Description,
        finding.Impact,
        finding.ImageURLs,
        finding.Link,
        finding.Recommend,
        finding.Author,
        finding.CreatedAt,
    )
    return err
}

func (repo *FindingRepository) GetFindingsByReportID(reportID int) ([]models.Finding, error) {
    query := `
        SELECT id, report_id, name, status, description, image_url, link, recommend, weakness, impact, severity, created_at, author
        FROM findings
        WHERE report_id = ?
    `
    rows, err := repo.DB.Query(query, reportID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var findings []models.Finding
    for rows.Next() {
        var finding models.Finding
        var createdAt string
        err := rows.Scan(&finding.ID, &finding.ReportID, &finding.Name, &finding.Status, &finding.Description, &finding.ImageURLs, &finding.Link, &finding.Recommend, &finding.Weakness, &finding.Impact, &finding.Severity, &createdAt, &finding.Author)
        if err != nil {
            return nil, err
        }
        // Parse the time using the full datetime format
        finding.CreatedAt, err = time.Parse("2006-01-02 15:04:05", createdAt)
        if err != nil {
            return nil, err
        }
        finding.ImageURLsArray = strings.Split(finding.ImageURLs, ",")
        findings = append(findings, finding)
    }
    return findings, nil
}

// GetAllFindingsForReport trả về tất cả các findings cho một report cụ thể
func (repo *FindingRepository) GetAllFindingsForReport(reportID int) ([]models.Finding, error) {
    var findings []models.Finding

    query := "SELECT id, report_id, name, status, severity, weakness, description, impact, image_url, link, recommend, author, created_at FROM findings WHERE report_id = ?"
    rows, err := repo.DB.Query(query, reportID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    for rows.Next() {
        var finding models.Finding
        var createdAt string
        if err := rows.Scan(&finding.ID, &finding.ReportID, &finding.Name, &finding.Status, &finding.Severity, &finding.Weakness, &finding.Description, &finding.Impact, &finding.ImageURLs, &finding.Link, &finding.Recommend, &finding.Author, &createdAt); err != nil {
            return nil, err
        }
        // Parse the time using the full datetime format
        finding.CreatedAt, err = time.Parse("2006-01-02 15:04:05", createdAt)
        if err != nil {
            return nil, err
        }
        finding.ImageURLsArray = strings.Split(finding.ImageURLs, ",")
        findings = append(findings, finding)
    }

    return findings, nil
}

func (repo *FindingRepository) DeleteFinding(findingID int) error {
    query := "DELETE FROM findings WHERE id = ?"
    _, err := repo.DB.Exec(query, findingID)
    return err
}

func (repo *FindingRepository) EditFinding(findingID int, finding *models.Finding) error {
    query := `
        UPDATE findings
        SET name = ?, status = ?, severity = ?, weakness = ?, description = ?, impact = ?, image_url = ?, link = ?, recommend = ?, author = ?
        WHERE id = ?
    `
    _, err := repo.DB.Exec(query,
        finding.Name,
        finding.Status,
        finding.Severity,
        finding.Weakness,
        finding.Description,
        finding.Impact,
        finding.ImageURLs,
        finding.Link,
        finding.Recommend,
        finding.Author,
        findingID,
    )
    return err
}


func (repo *FindingRepository) FilterFindings(name, status, severity, id, author string) ([]models.Finding, error) {
    var findings []models.Finding
    var queryParams []interface{}
    query := "SELECT id, report_id, name, status, severity, weakness, description, impact, image_url, link, recommend, author, created_at FROM findings WHERE 1=1"

    if name != "" {
        query += " AND name LIKE ?"
        queryParams = append(queryParams, "%"+name+"%")
    }
    if status != "" {
        query += " AND status = ?"
        queryParams = append(queryParams, status)
    }
    if severity != "" {
        query += " AND severity = ?"
        queryParams = append(queryParams, severity)
    }
    if author != "" {
        query += " AND author = ?"
        queryParams = append(queryParams, author)
    }
    if id != "" {
        query += " AND id = ?"
        queryParams = append(queryParams, id)
    }

    rows, err := repo.DB.Query(query, queryParams...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    for rows.Next() {
        var finding models.Finding
        var createdAt string
        err := rows.Scan(&finding.ID, &finding.ReportID, &finding.Name, &finding.Status, &finding.Severity, &finding.Weakness, &finding.Description, &finding.Impact, &finding.ImageURLs, &finding.Link, &finding.Recommend, &finding.Author, &createdAt)
        if err != nil {
            return nil, err
        }
        finding.CreatedAt, err = time.Parse("2006-01-02 15:04:05", createdAt)
        if err != nil {
            return nil, err
        }
        finding.ImageURLsArray = strings.Split(finding.ImageURLs, ",")
        findings = append(findings, finding)
    }

    return findings, nil
}