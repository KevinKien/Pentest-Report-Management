package controllers

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"math/rand"
	"time"

	"github.com/labstack/echo"

)

type UploadController struct {
	UploadDir string
}

func NewUploadController(uploadDir string) *UploadController {
	return &UploadController{UploadDir: uploadDir}
}

func (controller *UploadController) UploadFile(c echo.Context) error {
	// Source
	file, err := c.FormFile("file")
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}

	src, err := file.Open()
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}
	defer src.Close()

	// Generate a random string of 5 characters
	rand.Seed(time.Now().UnixNano())
	randomStr := RandomString(10)

	// Destination
	ext := filepath.Ext(file.Filename)
	newFileName := strings.TrimSuffix(file.Filename, ext) + "_" + randomStr + ext
	dstPath := filepath.Join(controller.UploadDir, newFileName)
	dst, err := os.Create(dstPath)
	if err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}
	defer dst.Close()

	// Copy
	if _, err = io.Copy(dst, src); err != nil {
		return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
	}

	// Create the file URL
	fileURL := fmt.Sprintf("/upload/%s", newFileName)

	return c.JSON(http.StatusOK, map[string]string{"url": fileURL})
}

// Function to generate a random string of specified length
func RandomString(length int) string {
	const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	var seededRand *rand.Rand = rand.New(
		rand.NewSource(time.Now().UnixNano()))
	b := make([]byte, length)
	for i := range b {
		b[i] = charset[seededRand.Intn(len(charset))]
	}
	return string(b)
}


// ViewFile handles serving files from the UploadDir
func (controller *UploadController) ViewFile(c echo.Context) error {
	fileName := c.Param("fileName")
	filePath := filepath.Join(controller.UploadDir, fileName)

	file, err := os.Open(filePath)
	if err != nil {
		return echo.NewHTTPError(http.StatusNotFound, "File not found")
	}
	defer file.Close()

	// Determine the content type
	contentType := getFileContentType(filePath)

	// Set the response headers to display the file inline
	c.Response().Header().Set("Content-Type", contentType)
	//c.Response().Header().Set("Content-Length", fmt.Sprintf("%d", fileInfo.Size()))

	// Set the response headers to display the file inline
	return c.Stream(http.StatusOK, contentType, file)
	//return c.File(filePath)
}

// getFileContentType determines the content type of a file based on its extension
func getFileContentType(filePath string) string {
	ext := strings.ToLower(filepath.Ext(filePath))
	switch ext {
	case ".jpg", ".jpeg":
		return "image/jpeg"
	case ".png":
		return "image/png"
	case ".gif":
		return "image/gif"
	case ".pdf":
		return "application/pdf"
	default:
		return "image/png"
	}
}